// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is generated by scripts/generate-config.js
// Run 'npm run generate-config' to regenerate

import { UptimeData, ResponseTimeData, ServiceStatus } from './types';

// Location definitions
export interface Location {
  name: string;
  code: string;
  coordinates: [number, number];
  region: string;
}

export const LOCATIONS: Location[] = [
  {
    "name": "Los Angeles",
    "code": "la",
    "coordinates": [
      -118.2437,
      34.0522
    ],
    "region": "North America"
  },
  {
    "name": "New York",
    "code": "ny",
    "coordinates": [
      -74.006,
      40.7128
    ],
    "region": "North America"
  },
  {
    "name": "London",
    "code": "ldn",
    "coordinates": [
      -0.1276,
      51.5074
    ],
    "region": "Europe"
  },
  {
    "name": "Singapore",
    "code": "sg",
    "coordinates": [
      103.8198,
      1.3521
    ],
    "region": "Asia-Pacific"
  },
  {
    "name": "São Paulo",
    "code": "sp",
    "coordinates": [
      -46.6333,
      -23.5505
    ],
    "region": "South America"
  }
];

// Service definitions
interface ServiceConfig {
  id: string;
  name: string;
  type: 'status-api' | 'website';
  statusApiUrl: string;
  statusPageUrl: string;
  apiFormat?: string;
}

export const SERVICES: ServiceConfig[] = [
  {
    "id": "Zapier",
    "name": "Zapier",
    "type": "status-api",
    "statusApiUrl": "https://status.zapier.com/api/v2/status.json",
    "statusPageUrl": "https://status.zapier.com",
    "apiFormat": "statuspage"
  },
  {
    "id": "Salesforce",
    "name": "Salesforce",
    "type": "status-api",
    "statusApiUrl": "https://api.status.salesforce.com/v1/instances/status",
    "statusPageUrl": "https://status.salesforce.com",
    "apiFormat": "custom"
  },
  {
    "id": "Google Cloud",
    "name": "Google Cloud",
    "type": "status-api",
    "statusApiUrl": "https://status.cloud.google.com/summary.json",
    "statusPageUrl": "https://status.cloud.google.com",
    "apiFormat": "custom"
  },
  {
    "id": "Microsoft Azure",
    "name": "Microsoft Azure",
    "type": "status-api",
    "statusApiUrl": "https://azure.status.microsoft.com/en-us/status/feed/",
    "statusPageUrl": "https://azure.status.microsoft.com/en-us/status",
    "apiFormat": "custom"
  },
  {
    "id": "CallRail",
    "name": "CallRail",
    "type": "status-api",
    "statusApiUrl": "https://status.callrail.com/api/v2/status.json",
    "statusPageUrl": "https://status.callrail.com",
    "apiFormat": "statuspage"
  },
  {
    "id": "WordPress Site",
    "name": "WordPress Site",
    "type": "website",
    "statusApiUrl": "https://hratchyan.com",
    "statusPageUrl": "https://hratchyan.com"
  }
];

// Service directory mapping (for Upptime-generated directories)
const SERVICE_DIR_MAP: Record<string, string> = {
  'Zapier (Los Angeles)': 'zapier-los-angeles',
  'Zapier (New York)': 'zapier-new-york',
  'Zapier (London)': 'zapier-london',
  'Zapier (Singapore)': 'zapier-singapore',
  'Zapier (São Paulo)': 'zapier-sao-paulo',
  'Salesforce (Los Angeles)': 'salesforce-los-angeles',
  'Salesforce (New York)': 'salesforce-new-york',
  'Salesforce (London)': 'salesforce-london',
  'Salesforce (Singapore)': 'salesforce-singapore',
  'Salesforce (São Paulo)': 'salesforce-sao-paulo',
  'Google Cloud (Los Angeles)': 'google-cloud-los-angeles',
  'Google Cloud (New York)': 'google-cloud-new-york',
  'Google Cloud (London)': 'google-cloud-london',
  'Google Cloud (Singapore)': 'google-cloud-singapore',
  'Google Cloud (São Paulo)': 'google-cloud-sao-paulo',
  'Microsoft Azure (Los Angeles)': 'microsoft-azure-los-angeles',
  'Microsoft Azure (New York)': 'microsoft-azure-new-york',
  'Microsoft Azure (London)': 'microsoft-azure-london',
  'Microsoft Azure (Singapore)': 'microsoft-azure-singapore',
  'Microsoft Azure (São Paulo)': 'microsoft-azure-sao-paulo',
  'CallRail (Los Angeles)': 'callrail-los-angeles',
  'CallRail (New York)': 'callrail-new-york',
  'CallRail (London)': 'callrail-london',
  'CallRail (Singapore)': 'callrail-singapore',
  'CallRail (São Paulo)': 'callrail-sao-paulo',
  'WordPress Site (Los Angeles)': 'wordpress-site-los-angeles',
  'WordPress Site (New York)': 'wordpress-site-new-york',
  'WordPress Site (London)': 'wordpress-site-london',
  'WordPress Site (Singapore)': 'wordpress-site-singapore',
  'WordPress Site (São Paulo)': 'wordpress-site-sao-paulo'
};

export async function getServiceStatus(serviceId: string, locationCode?: string): Promise<ServiceStatus> {
  const service = SERVICES.find(s => s.id === serviceId);
  const location = locationCode ? LOCATIONS.find(l => l.code === locationCode) : undefined;
  
  // Return error state if service not found in config
  if (!service) {
    return {
      name: serviceId,
      url: '',
      statusUrl: '',
      status: 'unknown',
      uptime: '0%',
      responseTime: 0,
      lastChecked: new Date().toISOString(),
      error: 'Service configuration not found',
    };
  }

  try {
    // Construct the directory name
    let dirName: string;
    if (location) {
      const fullName = `${service.name} (${location.name})`;
      dirName = SERVICE_DIR_MAP[fullName] || generateSlug(service.name, location.code);
    } else {
      dirName = service.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    }
    
    const [uptimeRes, responseTimeRes] = await Promise.all([
      fetch(`/api/${dirName}/uptime.json`),
      fetch(`/api/${dirName}/response-time.json`)
    ]);

    if (!uptimeRes.ok || !responseTimeRes.ok) {
      return {
        name: location ? `${service.name} (${location.name})` : service.name,
        url: service.statusApiUrl,
        statusUrl: service.statusPageUrl,
        status: 'unknown',
        uptime: 'N/A',
        responseTime: 0,
        lastChecked: new Date().toISOString(),
        error: `Unable to fetch data (HTTP ${uptimeRes.status || responseTimeRes.status})`,
        ...(location && { location })
      };
    }

    const uptimeData: UptimeData = await uptimeRes.json();
    const responseTimeData: ResponseTimeData = await responseTimeRes.json();

    // Determine status based on uptime percentage
    const uptimePercent = parseFloat(uptimeData.message.replace('%', ''));
    let status: 'up' | 'down' | 'degraded' = 'up';

    if (uptimePercent === 0) {
      status = 'down';
    } else if (uptimePercent < 99) {
      status = 'degraded';
    }

    // Extract response time (remove 'ms' and convert to number)
    const responseTimeMatch = responseTimeData.message.match(/(\d+)/);
    const responseTime = responseTimeMatch ? parseInt(responseTimeMatch[1]) : 0;

    return {
      name: location ? `${service.name} (${location.name})` : service.name,
      url: service.statusApiUrl,
      statusUrl: service.statusPageUrl,
      status,
      uptime: uptimeData.message,
      responseTime,
      lastChecked: new Date().toISOString(),
      ...(location && { location })
    };
  } catch (error) {
    console.error(`Error fetching status for ${serviceId}:`, error);
    return {
      name: location ? `${service.name} (${location.name})` : service.name,
      url: service.statusApiUrl,
      statusUrl: service.statusPageUrl,
      status: 'unknown',
      uptime: 'N/A',
      responseTime: 0,
      lastChecked: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Failed to fetch status data',
      ...(location && { location })
    };
  }
}

function generateSlug(serviceName: string, locationCode: string): string {
  const serviceSlug = serviceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  return `${serviceSlug}-${locationCode}`;
}

export async function getAllServicesStatus(): Promise<ServiceStatus[]> {
  const results: ServiceStatus[] = [];
  
  for (const service of SERVICES) {
    for (const location of LOCATIONS) {
      const status = await getServiceStatus(service.id, location.code);
      results.push(status);
    }
  }

  // Return all services, including those with errors
  return results;
}

export async function getServiceStatusByLocation(serviceId: string): Promise<Map<string, ServiceStatus>> {
  const statusMap = new Map<string, ServiceStatus>();
  
  for (const location of LOCATIONS) {
    const status = await getServiceStatus(serviceId, location.code);
    statusMap.set(location.code, status);
  }
  
  return statusMap;
}

// Aggregation functions for horizontal cards

import { AggregatedServiceStatus, LocationStatus, DetailedServiceStatus } from './types';

/**
 * Fetch detailed status from service's status API
 */
async function fetchDetailedStatus(service: ServiceConfig): Promise<DetailedServiceStatus | undefined> {
  if (service.type !== 'status-api') return undefined;
  
  try {
    const response = await fetch(service.statusApiUrl);
    if (!response.ok) return undefined;
    
    const data = await response.json();
    
    // Parse based on API format
    if (service.apiFormat === 'statuspage') {
      // StatusPage.io format (Zapier, CallRail)
      return {
        indicator: data.status?.indicator || 'none',
        description: data.status?.description || 'All Systems Operational',
        components: data.components?.map((c: any) => ({
          name: c.name,
          status: c.status
        })),
        incidents: data.incidents?.slice(0, 3).map((i: any) => ({
          name: i.name,
          status: i.status,
          created_at: i.created_at
        }))
      };
    }
    
    // For custom formats, return basic info
    return {
      indicator: 'none',
      description: 'Service operational'
    };
  } catch (error) {
    console.error(`Error fetching detailed status for ${service.name}:`, error);
    return undefined;
  }
}

/**
 * Get aggregated status for a single service across all locations
 */
export async function getAggregatedServiceStatus(serviceId: string): Promise<AggregatedServiceStatus> {
  const service = SERVICES.find(s => s.id === serviceId);
  
  if (!service) {
    throw new Error(`Service ${serviceId} not found`);
  }
  
  // Fetch status from all locations
  const locationStatuses: LocationStatus[] = [];
  let totalResponseTime = 0;
  let uptimeValues: number[] = [];
  let hasErrors = false;
  
  for (const location of LOCATIONS) {
    const status = await getServiceStatus(serviceId, location.code);
    
    locationStatuses.push({
      location,
      responseTime: status.responseTime,
      status: status.status,
      uptime: status.uptime,
      lastChecked: status.lastChecked,
      error: status.error
    });
    
    if (status.error) {
      hasErrors = true;
    } else {
      totalResponseTime += status.responseTime;
      const uptimePercent = parseFloat(status.uptime.replace('%', ''));
      if (!isNaN(uptimePercent)) {
        uptimeValues.push(uptimePercent);
      }
    }
  }
  
  // Calculate averages
  const validLocations = locationStatuses.filter(l => !l.error);
  const averageResponseTime = validLocations.length > 0 
    ? Math.round(totalResponseTime / validLocations.length)
    : 0;
  
  const overallUptime = uptimeValues.length > 0
    ? `${(uptimeValues.reduce((a, b) => a + b, 0) / uptimeValues.length).toFixed(2)}%`
    : 'N/A';
  
  // Determine overall status
  let overallStatus: 'up' | 'down' | 'degraded' | 'unknown' = 'up';
  const downCount = locationStatuses.filter(l => l.status === 'down').length;
  const degradedCount = locationStatuses.filter(l => l.status === 'degraded').length;
  
  if (downCount >= locationStatuses.length / 2) {
    overallStatus = 'down';
  } else if (downCount > 0 || degradedCount > 0) {
    overallStatus = 'degraded';
  } else if (hasErrors) {
    overallStatus = 'unknown';
  }
  
  // Fetch detailed status for status-api services
  const detailedStatus = await fetchDetailedStatus(service);
  
  // Determine status message
  let statusMessage = 'All Systems Operational';
  if (detailedStatus?.description) {
    statusMessage = detailedStatus.description;
  } else if (overallStatus === 'down') {
    statusMessage = 'Service Down';
  } else if (overallStatus === 'degraded') {
    statusMessage = 'Performance Degraded';
  } else if (overallStatus === 'unknown') {
    statusMessage = 'Status Unknown';
  }
  
  return {
    id: service.id,
    name: service.name,
    type: service.type,
    overallStatus,
    statusMessage,
    statusPageUrl: service.statusPageUrl,
    locations: locationStatuses,
    averageResponseTime,
    overallUptime,
    lastChecked: new Date().toISOString(),
    detailedStatus,
    primaryLocation: 'la' // Los Angeles as priority
  };
}

/**
 * Get aggregated status for all services
 */
export async function getAllAggregatedServicesStatus(): Promise<AggregatedServiceStatus[]> {
  const results: AggregatedServiceStatus[] = [];
  
  for (const service of SERVICES) {
    try {
      const aggregated = await getAggregatedServiceStatus(service.id);
      results.push(aggregated);
    } catch (error) {
      console.error(`Error getting aggregated status for ${service.id}:`, error);
    }
  }
  
  return results;
}
