#!/usr/bin/env node

/**
 * Configuration Generator for Status Monitor
 * 
 * This script reads service and location configurations and generates:
 * 1. .uptimerc.yml - Upptime configuration with Globalping locations
 * 2. src/lib/api.ts - TypeScript API file with service definitions
 * 
 * Usage: node scripts/generate-config.js
 * Or: npm run generate-config
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

// File paths
const SERVICES_FILE = path.join(__dirname, '../config/services.yml');
const LOCATIONS_FILE = path.join(__dirname, '../config/locations.yml');
const UPPTIME_RC_FILE = path.join(__dirname, '../.upptimerc.yml');
const API_TS_FILE = path.join(__dirname, '../src/lib/api.ts');

// Read and parse YAML files
function readYAML(filePath) {
  try {
    const fileContents = fs.readFileSync(filePath, 'utf8');
    return yaml.load(fileContents);
  } catch (error) {
    console.error(`Error reading ${filePath}:`, error.message);
    process.exit(1);
  }
}

// Generate slug from service name and location name to match Upptime's behavior
// Upptime generates slugs from the full 'name' field, not custom slug values
function generateSlug(serviceName, locationName) {
  // Upptime creates slugs from "ServiceName (LocationName)" format
  const fullName = `${serviceName} (${locationName})`;
  // Convert to lowercase and replace non-alphanumeric chars with hyphens
  const slug = fullName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
  return slug;
}

// Generate .upptimerc.yml
function generateUptimeRC(services, locations) {
  const sites = [];
  
  // Generate service √ó location combinations
  services.services.forEach(service => {
    locations.locations.forEach(location => {
      // Use statusApiUrl for status-api type, url for website type
      const monitorUrl = service.type === 'status-api' ? service.statusApiUrl : service.url;
      
      sites.push({
        name: `${service.name} (${location.name})`,
        url: monitorUrl,
        type: 'globalping',
        location: location.globalping,
        slug: generateSlug(service.name, location.name),
        ...(service.method && { method: service.method }),
        ...(service.expectedStatusCodes && { expectedStatusCodes: service.expectedStatusCodes }),
        ...(service.maxResponseTime && { maxResponseTime: service.maxResponseTime })
      });
    });
  });

  const config = {
    owner: 'hratchyan',
    repo: 'status',
    'user-agent': 'hratchyan-status-monitor',
    sites,
    'status-website': {
      name: 'Marketing Operations Status',
      cname: 'statuscheck.hratchyan.com',
      baseUrl: '/',
      introTitle: '**Marketing Operations Status**',
      introMessage: 'Real-time monitoring of marketing tools and services from multiple global locations',
      theme: 'light',
      navbar: [
        {title: 'Status', href: '/'},
        {title: 'History', href: '/history'}
      ],
      logo: 'https://hratchyan.com/wp-content/uploads/2024/01/hratchyan-logo.png',
      favicon: 'https://hratchyan.com/favicon.ico',
      colors: {
        primary: '#1a365d',
        secondary: '#2d3748',
        success: '#38a169',
        warning: '#d69e2e',
        danger: '#e53e3e',
        info: '#3182ce'
      }
    },
    skipDescriptionUpdate: true,
    skipTopicsUpdate: true,
    skipHomepageUpdate: true
  };

  const yamlStr = yaml.dump(config, {
    lineWidth: -1,
    noRefs: true
  });

  fs.writeFileSync(UPPTIME_RC_FILE, yamlStr, 'utf8');
  console.log(`‚úÖ Generated .upptimerc.yml with ${sites.length} monitoring endpoints`);
  console.log(`   (${services.services.length} services √ó ${locations.locations.length} locations)`);
}

// Generate src/lib/api.ts
function generateAPIFile(services, locations) {
  const apiContent = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is generated by scripts/generate-config.js
// Run 'npm run generate-config' to regenerate

import { UptimeData, ResponseTimeData, ServiceStatus } from './types';

// Location definitions
export interface Location {
  name: string;
  code: string;
  coordinates: [number, number];
  region: string;
}

export const LOCATIONS: Location[] = ${JSON.stringify(
    locations.locations.map(loc => ({
      name: loc.name,
      code: loc.code,
      coordinates: loc.coordinates,
      region: loc.region
    })),
    null,
    2
  )};

// Service definitions
interface ServiceConfig {
  id: string;
  name: string;
  type: 'status-api' | 'website';
  statusApiUrl: string;
  statusPageUrl: string;
  apiFormat?: string;
}

export const SERVICES: ServiceConfig[] = ${JSON.stringify(
    services.services.map(svc => ({
      id: svc.name,
      name: svc.name,
      type: svc.type,
      statusApiUrl: svc.statusApiUrl || svc.url,
      statusPageUrl: svc.statusPageUrl,
      apiFormat: svc.apiFormat
    })),
    null,
    2
  )};

// Service directory mapping (for Upptime-generated directories)
const SERVICE_DIR_MAP: Record<string, string> = {
${services.services.map(svc => 
  locations.locations.map(loc => 
    `  '${svc.name} (${loc.name})': '${generateSlug(svc.name, loc.name)}'`
  ).join(',\n')
).join(',\n')}
};

export async function getServiceStatus(serviceId: string, locationCode?: string): Promise<ServiceStatus> {
  const service = SERVICES.find(s => s.id === serviceId);
  const location = locationCode ? LOCATIONS.find(l => l.code === locationCode) : undefined;
  
  // Return error state if service not found in config
  if (!service) {
    return {
      name: serviceId,
      url: '',
      statusUrl: '',
      status: 'unknown',
      uptime: '0%',
      responseTime: 0,
      lastChecked: new Date().toISOString(),
      error: 'Service configuration not found',
    };
  }

  try {
    // Construct the directory name
    let dirName: string;
    if (location) {
      const fullName = \`\${service.name} (\${location.name})\`;
      dirName = SERVICE_DIR_MAP[fullName] || generateSlug(service.name, location.code);
    } else {
      dirName = service.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    }
    
    const [uptimeRes, responseTimeRes] = await Promise.all([
      fetch(\`/api/\${dirName}/uptime.json\`),
      fetch(\`/api/\${dirName}/response-time.json\`)
    ]);

    if (!uptimeRes.ok || !responseTimeRes.ok) {
      return {
        name: location ? \`\${service.name} (\${location.name})\` : service.name,
        url: service.statusApiUrl,
        statusUrl: service.statusPageUrl,
        status: 'unknown',
        uptime: 'N/A',
        responseTime: 0,
        lastChecked: new Date().toISOString(),
        error: \`Unable to fetch data (HTTP \${uptimeRes.status || responseTimeRes.status})\`,
        ...(location && { location })
      };
    }

    const uptimeData: UptimeData = await uptimeRes.json();
    const responseTimeData: ResponseTimeData = await responseTimeRes.json();

    // Determine status based on uptime percentage
    const uptimePercent = parseFloat(uptimeData.message.replace('%', ''));
    let status: 'up' | 'down' | 'degraded' = 'up';

    if (uptimePercent === 0) {
      status = 'down';
    } else if (uptimePercent < 99) {
      status = 'degraded';
    }

    // Extract response time (remove 'ms' and convert to number)
    const responseTimeMatch = responseTimeData.message.match(/(\\d+)/);
    const responseTime = responseTimeMatch ? parseInt(responseTimeMatch[1]) : 0;

    return {
      name: location ? \`\${service.name} (\${location.name})\` : service.name,
      url: service.statusApiUrl,
      statusUrl: service.statusPageUrl,
      status,
      uptime: uptimeData.message,
      responseTime,
      lastChecked: new Date().toISOString(),
      ...(location && { location })
    };
  } catch (error) {
    console.error(\`Error fetching status for \${serviceId}:\`, error);
    return {
      name: location ? \`\${service.name} (\${location.name})\` : service.name,
      url: service.statusApiUrl,
      statusUrl: service.statusPageUrl,
      status: 'unknown',
      uptime: 'N/A',
      responseTime: 0,
      lastChecked: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Failed to fetch status data',
      ...(location && { location })
    };
  }
}

function generateSlug(serviceName: string, locationCode: string): string {
  const serviceSlug = serviceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  return \`\${serviceSlug}-\${locationCode}\`;
}

export async function getAllServicesStatus(): Promise<ServiceStatus[]> {
  const results: ServiceStatus[] = [];
  
  for (const service of SERVICES) {
    for (const location of LOCATIONS) {
      const status = await getServiceStatus(service.id, location.code);
      results.push(status);
    }
  }

  // Return all services, including those with errors
  return results;
}

export async function getServiceStatusByLocation(serviceId: string): Promise<Map<string, ServiceStatus>> {
  const statusMap = new Map<string, ServiceStatus>();
  
  for (const location of LOCATIONS) {
    const status = await getServiceStatus(serviceId, location.code);
    statusMap.set(location.code, status);
  }
  
  return statusMap;
}

// Aggregation functions for horizontal cards

import { AggregatedServiceStatus, LocationStatus, DetailedServiceStatus } from './types';

/**
 * Fetch detailed status from service's status API
 */
async function fetchDetailedStatus(service: ServiceConfig): Promise<DetailedServiceStatus | undefined> {
  if (service.type !== 'status-api') return undefined;
  
  try {
    const response = await fetch(service.statusApiUrl);
    if (!response.ok) return undefined;
    
    const data = await response.json();
    
    // Parse based on API format
    if (service.apiFormat === 'statuspage') {
      // StatusPage.io format (Zapier, CallRail)
      return {
        indicator: data.status?.indicator || 'none',
        description: data.status?.description || 'All Systems Operational',
        components: data.components?.map((c: any) => ({
          name: c.name,
          status: c.status
        })),
        incidents: data.incidents?.slice(0, 3).map((i: any) => ({
          name: i.name,
          status: i.status,
          created_at: i.created_at
        }))
      };
    }
    
    // For custom formats, return basic info
    return {
      indicator: 'none',
      description: 'Service operational'
    };
  } catch (error) {
    console.error(\`Error fetching detailed status for \${service.name}:\`, error);
    return undefined;
  }
}

/**
 * Get aggregated status for a single service across all locations
 */
export async function getAggregatedServiceStatus(serviceId: string): Promise<AggregatedServiceStatus> {
  const service = SERVICES.find(s => s.id === serviceId);
  
  if (!service) {
    throw new Error(\`Service \${serviceId} not found\`);
  }
  
  // Fetch status from all locations
  const locationStatuses: LocationStatus[] = [];
  let totalResponseTime = 0;
  let uptimeValues: number[] = [];
  let hasErrors = false;
  
  for (const location of LOCATIONS) {
    const status = await getServiceStatus(serviceId, location.code);
    
    locationStatuses.push({
      location,
      responseTime: status.responseTime,
      status: status.status,
      uptime: status.uptime,
      lastChecked: status.lastChecked,
      error: status.error
    });
    
    if (status.error) {
      hasErrors = true;
    } else {
      totalResponseTime += status.responseTime;
      const uptimePercent = parseFloat(status.uptime.replace('%', ''));
      if (!isNaN(uptimePercent)) {
        uptimeValues.push(uptimePercent);
      }
    }
  }
  
  // Calculate averages
  const validLocations = locationStatuses.filter(l => !l.error);
  const averageResponseTime = validLocations.length > 0 
    ? Math.round(totalResponseTime / validLocations.length)
    : 0;
  
  const overallUptime = uptimeValues.length > 0
    ? \`\${(uptimeValues.reduce((a, b) => a + b, 0) / uptimeValues.length).toFixed(2)}%\`
    : 'N/A';
  
  // Determine overall status
  let overallStatus: 'up' | 'down' | 'degraded' | 'unknown' = 'up';
  const downCount = locationStatuses.filter(l => l.status === 'down').length;
  const degradedCount = locationStatuses.filter(l => l.status === 'degraded').length;
  
  if (downCount >= locationStatuses.length / 2) {
    overallStatus = 'down';
  } else if (downCount > 0 || degradedCount > 0) {
    overallStatus = 'degraded';
  } else if (hasErrors) {
    overallStatus = 'unknown';
  }
  
  // Fetch detailed status for status-api services
  const detailedStatus = await fetchDetailedStatus(service);
  
  // Determine status message
  let statusMessage = 'All Systems Operational';
  if (detailedStatus?.description) {
    statusMessage = detailedStatus.description;
  } else if (overallStatus === 'down') {
    statusMessage = 'Service Down';
  } else if (overallStatus === 'degraded') {
    statusMessage = 'Performance Degraded';
  } else if (overallStatus === 'unknown') {
    statusMessage = 'Status Unknown';
  }
  
  return {
    id: service.id,
    name: service.name,
    type: service.type,
    overallStatus,
    statusMessage,
    statusPageUrl: service.statusPageUrl,
    locations: locationStatuses,
    averageResponseTime,
    overallUptime,
    lastChecked: new Date().toISOString(),
    detailedStatus,
    primaryLocation: 'la' // Los Angeles as priority
  };
}

/**
 * Get aggregated status for all services
 */
export async function getAllAggregatedServicesStatus(): Promise<AggregatedServiceStatus[]> {
  const results: AggregatedServiceStatus[] = [];
  
  for (const service of SERVICES) {
    try {
      const aggregated = await getAggregatedServiceStatus(service.id);
      results.push(aggregated);
    } catch (error) {
      console.error(\`Error getting aggregated status for \${service.id}:\`, error);
    }
  }
  
  return results;
}
`;

  fs.writeFileSync(API_TS_FILE, apiContent, 'utf8');
  console.log(`‚úÖ Generated src/lib/api.ts with ${services.services.length} services and ${locations.locations.length} locations`);
}

// Main execution
function main() {
  console.log('üîß Generating configuration files...\n');
  
  // Read configuration files
  const services = readYAML(SERVICES_FILE);
  const locations = readYAML(LOCATIONS_FILE);
  
  // Validate
  if (!services.services || !Array.isArray(services.services)) {
    console.error('‚ùå Error: services.yml must contain a "services" array');
    process.exit(1);
  }
  
  if (!locations.locations || !Array.isArray(locations.locations)) {
    console.error('‚ùå Error: locations.yml must contain a "locations" array');
    process.exit(1);
  }
  
  // Generate files
  generateUptimeRC(services, locations);
  generateAPIFile(services, locations);
  
  console.log('\n‚ú® Configuration generation complete!');
  console.log('\nüìù Next steps:');
  console.log('   1. Review the generated .upptimerc.yml file');
  console.log('   2. Commit and push changes to trigger monitoring setup');
  console.log('   3. (Optional) Add GLOBALPING_TOKEN to GitHub secrets for higher rate limits');
}

// Run the script
main();
