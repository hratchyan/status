#!/usr/bin/env node

/**
 * Configuration Generator for Status Monitor
 * 
 * This script reads service and location configurations and generates:
 * 1. .uptimerc.yml - Upptime configuration with Globalping locations
 * 2. src/lib/api.ts - TypeScript API file with service definitions
 * 
 * Usage: node scripts/generate-config.js
 * Or: npm run generate-config
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

// File paths
const SERVICES_FILE = path.join(__dirname, '../config/services.yml');
const LOCATIONS_FILE = path.join(__dirname, '../config/locations.yml');
const UPPTIME_RC_FILE = path.join(__dirname, '../.uptimerc.yml');
const API_TS_FILE = path.join(__dirname, '../src/lib/api.ts');

// Read and parse YAML files
function readYAML(filePath) {
  try {
    const fileContents = fs.readFileSync(filePath, 'utf8');
    return yaml.load(fileContents);
  } catch (error) {
    console.error(`Error reading ${filePath}:`, error.message);
    process.exit(1);
  }
}

// Generate slug from service name and location code
function generateSlug(serviceName, locationCode) {
  const serviceSlug = serviceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  return `${serviceSlug}-${locationCode}`;
}

// Generate .upptimerc.yml
function generateUptimeRC(services, locations) {
  const sites = [];
  
  // Generate service √ó location combinations
  services.services.forEach(service => {
    locations.locations.forEach(location => {
      sites.push({
        name: `${service.name} (${location.name})`,
        url: service.url,
        type: 'globalping',
        location: location.globalping,
        slug: generateSlug(service.name, location.code),
        ...(service.method && { method: service.method }),
        ...(service.expectedStatusCodes && { expectedStatusCodes: service.expectedStatusCodes }),
        ...(service.maxResponseTime && { maxResponseTime: service.maxResponseTime })
      });
    });
  });

  const config = {
    owner: 'hratchyan',
    repo: 'status',
    'user-agent': 'hratchyan-status-monitor',
    sites,
    'status-website': {
      name: 'Marketing Operations Status',
      cname: 'statuscheck.hratchyan.com',
      baseUrl: '/',
      introTitle: '**Marketing Operations Status**',
      introMessage: 'Real-time monitoring of marketing tools and services from multiple global locations',
      theme: 'light',
      navbar: [
        {title: 'Status', href: '/'},
        {title: 'History', href: '/history'}
      ],
      logo: 'https://hratchyan.com/wp-content/uploads/2024/01/hratchyan-logo.png',
      favicon: 'https://hratchyan.com/favicon.ico',
      colors: {
        primary: '#1a365d',
        secondary: '#2d3748',
        success: '#38a169',
        warning: '#d69e2e',
        danger: '#e53e3e',
        info: '#3182ce'
      }
    },
    skipDescriptionUpdate: true,
    skipTopicsUpdate: true,
    skipHomepageUpdate: true
  };

  const yamlStr = yaml.dump(config, {
    lineWidth: -1,
    noRefs: true
  });

  fs.writeFileSync(UPPTIME_RC_FILE, yamlStr, 'utf8');
  console.log(`‚úÖ Generated .uptimerc.yml with ${sites.length} monitoring endpoints`);
  console.log(`   (${services.services.length} services √ó ${locations.locations.length} locations)`);
}

// Generate src/lib/api.ts
function generateAPIFile(services, locations) {
  const apiContent = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// This file is generated by scripts/generate-config.js
// Run 'npm run generate-config' to regenerate

import { UptimeData, ResponseTimeData, ServiceStatus } from './types';

// Location definitions
export interface Location {
  name: string;
  code: string;
  coordinates: [number, number];
  region: string;
}

export const LOCATIONS: Location[] = ${JSON.stringify(
    locations.locations.map(loc => ({
      name: loc.name,
      code: loc.code,
      coordinates: loc.coordinates,
      region: loc.region
    })),
    null,
    2
  )};

// Service definitions
interface ServiceConfig {
  id: string;
  name: string;
  url: string;
  statusUrl: string;
}

export const SERVICES: ServiceConfig[] = ${JSON.stringify(
    services.services.map(svc => ({
      id: svc.name,
      name: svc.name,
      url: svc.url,
      statusUrl: svc.statusUrl
    })),
    null,
    2
  )};

// Service directory mapping (for Upptime-generated directories)
const SERVICE_DIR_MAP: Record<string, string> = {
${services.services.map(svc => 
  locations.locations.map(loc => 
    `  '${svc.name} (${loc.name})': '${generateSlug(svc.name, loc.code)}'`
  ).join(',\n')
).join(',\n')}
};

export async function getServiceStatus(serviceId: string, locationCode?: string): Promise<ServiceStatus> {
  const service = SERVICES.find(s => s.id === serviceId);
  const location = locationCode ? LOCATIONS.find(l => l.code === locationCode) : undefined;
  
  // Return error state if service not found in config
  if (!service) {
    return {
      name: serviceId,
      url: '',
      statusUrl: '',
      status: 'unknown',
      uptime: '0%',
      responseTime: 0,
      lastChecked: new Date().toISOString(),
      error: 'Service configuration not found',
    };
  }

  try {
    // Construct the directory name
    let dirName: string;
    if (location) {
      const fullName = \`\${service.name} (\${location.name})\`;
      dirName = SERVICE_DIR_MAP[fullName] || generateSlug(service.name, location.code);
    } else {
      dirName = service.name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    }
    
    const [uptimeRes, responseTimeRes] = await Promise.all([
      fetch(\`/api/\${dirName}/uptime.json\`),
      fetch(\`/api/\${dirName}/response-time.json\`)
    ]);

    if (!uptimeRes.ok || !responseTimeRes.ok) {
      return {
        name: location ? \`\${service.name} (\${location.name})\` : service.name,
        url: service.url,
        statusUrl: service.statusUrl,
        status: 'unknown',
        uptime: 'N/A',
        responseTime: 0,
        lastChecked: new Date().toISOString(),
        error: \`Unable to fetch data (HTTP \${uptimeRes.status || responseTimeRes.status})\`,
        ...(location && { location })
      };
    }

    const uptimeData: UptimeData = await uptimeRes.json();
    const responseTimeData: ResponseTimeData = await responseTimeRes.json();

    // Determine status based on uptime percentage
    const uptimePercent = parseFloat(uptimeData.message.replace('%', ''));
    let status: 'up' | 'down' | 'degraded' = 'up';

    if (uptimePercent === 0) {
      status = 'down';
    } else if (uptimePercent < 99) {
      status = 'degraded';
    }

    // Extract response time (remove 'ms' and convert to number)
    const responseTimeMatch = responseTimeData.message.match(/(\\d+)/);
    const responseTime = responseTimeMatch ? parseInt(responseTimeMatch[1]) : 0;

    return {
      name: location ? \`\${service.name} (\${location.name})\` : service.name,
      url: service.url,
      statusUrl: service.statusUrl,
      status,
      uptime: uptimeData.message,
      responseTime,
      lastChecked: new Date().toISOString(),
      ...(location && { location })
    };
  } catch (error) {
    console.error(\`Error fetching status for \${serviceId}:\`, error);
    return {
      name: location ? \`\${service.name} (\${location.name})\` : service.name,
      url: service.url,
      statusUrl: service.statusUrl,
      status: 'unknown',
      uptime: 'N/A',
      responseTime: 0,
      lastChecked: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Failed to fetch status data',
      ...(location && { location })
    };
  }
}

function generateSlug(serviceName: string, locationCode: string): string {
  const serviceSlug = serviceName.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  return \`\${serviceSlug}-\${locationCode}\`;
}

export async function getAllServicesStatus(): Promise<ServiceStatus[]> {
  const results: ServiceStatus[] = [];
  
  for (const service of SERVICES) {
    for (const location of LOCATIONS) {
      const status = await getServiceStatus(service.id, location.code);
      results.push(status);
    }
  }

  // Return all services, including those with errors
  return results;
}

export async function getServiceStatusByLocation(serviceId: string): Promise<Map<string, ServiceStatus>> {
  const statusMap = new Map<string, ServiceStatus>();
  
  for (const location of LOCATIONS) {
    const status = await getServiceStatus(serviceId, location.code);
    statusMap.set(location.code, status);
  }
  
  return statusMap;
}
`;

  fs.writeFileSync(API_TS_FILE, apiContent, 'utf8');
  console.log(`‚úÖ Generated src/lib/api.ts with ${services.services.length} services and ${locations.locations.length} locations`);
}

// Main execution
function main() {
  console.log('üîß Generating configuration files...\n');
  
  // Read configuration files
  const services = readYAML(SERVICES_FILE);
  const locations = readYAML(LOCATIONS_FILE);
  
  // Validate
  if (!services.services || !Array.isArray(services.services)) {
    console.error('‚ùå Error: services.yml must contain a "services" array');
    process.exit(1);
  }
  
  if (!locations.locations || !Array.isArray(locations.locations)) {
    console.error('‚ùå Error: locations.yml must contain a "locations" array');
    process.exit(1);
  }
  
  // Generate files
  generateUptimeRC(services, locations);
  generateAPIFile(services, locations);
  
  console.log('\n‚ú® Configuration generation complete!');
  console.log('\nüìù Next steps:');
  console.log('   1. Review the generated .upptimerc.yml file');
  console.log('   2. Commit and push changes to trigger monitoring setup');
  console.log('   3. (Optional) Add GLOBALPING_TOKEN to GitHub secrets for higher rate limits');
}

// Run the script
main();
